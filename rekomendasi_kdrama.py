# -*- coding: utf-8 -*-
"""rekomendasi-kdrama.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18DeFSvoG47VsDH-73YzLVx8fZR6wx9-I

# Sistem Rekomendasi K-Drama - Khoirotun Hisan

## Project Overview
Proyek ini bertujuan untuk membangun sistem rekomendasi drama Korea (K-Drama) menggunakan pendekatan Content-Based Filtering, yang merekomendasikan drama berdasarkan kemiripan konten (genre).

Dengan meningkatnya minat global terhadap K-Drama, pengguna membutuhkan cara yang lebih efisien untuk menemukan tontonan yang relevan dengan selera mereka. Proyek ini diharapkan dapat membantu pengguna mendapatkan rekomendasi drama berdasarkan genre yang mereka sukai sebelumnya.

## Business Understanding
- **Problem Statement**: Banyak penonton K-Drama merasa kesulitan menemukan drama baru yang sesuai dengan selera mereka karena terlalu banyak pilihan.

- **Goals**: Membangun sistem rekomendasi yang dapat memberikan daftar drama Korea yang mirip berdasarkan genre dari drama yang disukai pengguna.

## Data Understanding

Dataset yang digunakan berjudul **Top 250 Korean Dramas (KDrama)**, yang dapat diakses melalui Kaggle:

ðŸ”— [https://www.kaggle.com/datasets/ahbab911/top-250-korean-dramas-kdrama-dataset](https://www.kaggle.com/datasets/ahbab911/top-250-korean-dramas-kdrama-dataset)

### Informasi Umum:

* Jumlah data: 250 drama
* Fitur utama:

  * `Title`: Judul drama
  * `Genre`: Genre utama (dipisahkan koma)
  * `Rating`: Nilai rating IMDb
  * `Year`: Tahun rilis
  * `Synopsis`: Sinopsis drama

### Visualisasi:

Distribusi rating drama menunjukkan bahwa sebagian besar drama berada pada kisaran rating 8.0 â€“ 9.5, yang mencerminkan kualitas tinggi dari drama yang terkurasi.
"""

import pandas as pd
df = pd.read_csv("/content/kdrama.csv")
df.head()

df.info()
df.isnull().sum()

"""## Univariate Exploratory Data Analysis

Pada tahap ini kita menganalisis setiap fitur secara individu. Fokus utama ada pada fitur `Rating`, `Genre`, dan `Year of release` karena akan membantu dalam sistem rekomendasi.

Kita juga akan visualisasikan distribusi rating dan jumlah drama per tahun rilis.
"""

import matplotlib.pyplot as plt
import seaborn as sns

# Distribusi rating
plt.figure(figsize=(8,4))
sns.histplot(df['Rating'], bins=20, kde=True, color='salmon')
plt.title('Distribusi Rating Drama Korea')
plt.xlabel('Rating')
plt.ylabel('Jumlah Drama')
plt.show()

# Jumlah drama berdasarkan tahun rilis
plt.figure(figsize=(8,4))
sns.countplot(x='Year of release', data=df, palette='Blues_r')
plt.title('Jumlah Drama Berdasarkan Tahun Rilis')
plt.xticks(rotation=45)
plt.ylabel('Jumlah Drama')
plt.show()

"""## Data Preprocessing

Pada tahap ini, kita membersihkan data dan menghapus kolom yang tidak diperlukan untuk sistem rekomendasi.

Langkah-langkah preprocessing:
- Pilih kolom-kolom relevan: `Name`, `Synopsis`, `Genre`, dan `Rating`
- Hapus nilai duplikat
- Tangani nilai null jika ada
- Gabungkan kolom `Synopsis` dan `Genre` sebagai dasar fitur konten
"""

df_filtered = df[['Name', 'Synopsis', 'Genre', 'Rating']].copy()
df_filtered.drop_duplicates(subset='Name', inplace=True)
df_filtered.dropna(subset=['Synopsis', 'Genre'], inplace=True)
df_filtered['combined_features'] = df_filtered['Genre'].fillna('') + " " + df_filtered['Synopsis'].fillna('')
df_filtered.head()

"""## Data Preparation

Sebelum membuat model, kita perlu menyiapkan representasi numerik dari fitur teks yang telah digabungkan. Kita akan menggunakan teknik **TF-IDF Vectorization**.

Langkah-langkah:
- Lakukan TF-IDF pada kolom `combined_features`
- Hitung kesamaan antar drama dengan **cosine similarity**
"""

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df_filtered['combined_features'])

cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

indices = pd.Series(df_filtered.index, index=df_filtered['Name']).drop_duplicates()

"""## Model Development dengan Content-Based Filtering

Sistem rekomendasi dibuat berdasarkan kemiripan konten antar drama menggunakan cosine similarity dari fitur gabungan (genre + sinopsis).

Fungsi `recommend_drama(title)` akan mengembalikan 5 drama yang paling mirip dengan judul input.
"""

# Fungsi sistem rekomendasi
def recommend_drama(title, similarity=cosine_sim):
    idx = indices.get(title)
    if idx is None:
        return f"Drama '{title}' tidak ditemukan dalam data."

    sim_scores = list(enumerate(similarity[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:6]

    drama_indices = [i[0] for i in sim_scores]
    return df_filtered[['Name', 'Rating']].iloc[drama_indices]

# Contoh rekomendasi
recommend_drama("My Mister")

"""## Evaluation

Evaluasi sistem rekomendasi dilakukan dengan menggunakan **cosine similarity** sebagai metrik utama. Karena pendekatan ini berbasis konten, kita tidak memiliki data eksplisit dari pengguna (seperti rating per user). Oleh karena itu, kita menilai kinerja model berdasarkan seberapa baik sistem menghasilkan rekomendasi yang relevan secara semantik.

- #### Evaluasi Kualitatif

Kita dapat mengevaluasi sistem dengan melihat apakah drama yang direkomendasikan memiliki kesamaan genre, tema, atau narasi dengan drama input.

Contoh: Jika kita merekomendasikan drama berdasarkan "Move to Heaven", kita mengharapkan drama dengan tema kehidupan, keluarga, atau kisah emosional akan muncul sebagai hasil.

- #### Evaluasi Kuantitatif

Meskipun metrik seperti Precision, Recall, MAP atau NDCG umum digunakan untuk mengevaluasi sistem rekomendasi, pendekatan berbasis konten murni tanpa data user membuat evaluasi ini tidak langsung diterapkan. Sebagai pengganti, kita dapat menghitung:

**Skor kesamaan rata-rata** dari hasil top-N rekomendasi.
"""

# Evaluasi kuantitatif: skor kesamaan rata-rata dari hasil rekomendasi
def evaluate_similarity(title, top_n=5):
    idx = indices.get(title)
    if idx is None:
        return f"Drama '{title}' tidak ditemukan."

    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:top_n+1]
    avg_score = sum([score for _, score in sim_scores]) / top_n
    return f"Rata-rata skor similarity dari top-{top_n} rekomendasi untuk '{title}': {avg_score:.4f}"

evaluate_similarity("My Mister")

"""## Opsi Pendekatan Tambahan: CountVectorizer
### Pendekatan Kedua: Content-Based Filtering dengan CountVectorizer

Sebagai pembanding, kita menggunakan pendekatan kedua dengan **CountVectorizer** alih-alih TF-IDF. Ini akan memperlakukan kata-kata dengan bobot frekuensi mentah, yang kadang cocok jika kita ingin menangkap semua kata secara eksplisit tanpa penalti terhadap kata umum.

Langkah-langkah:
- Gunakan CountVectorizer pada `combined_features`
- Hitung cosine similarity
- Buat sistem rekomendasi kedua
"""

from sklearn.feature_extraction.text import CountVectorizer

# Count Vectorizer
count = CountVectorizer(stop_words='english')
count_matrix = count.fit_transform(df_filtered['combined_features'])

# Cosine similarity dari count matrix
cosine_sim_count = cosine_similarity(count_matrix, count_matrix)

# Sistem rekomendasi kedua
def recommend_drama_count(title, similarity=cosine_sim_count):
    idx = indices.get(title)
    if idx is None:
        return f"Drama '{title}' tidak ditemukan."

    sim_scores = list(enumerate(similarity[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:6]
    drama_indices = [i[0] for i in sim_scores]
    return df_filtered[['Name', 'Rating']].iloc[drama_indices]

# Contoh penggunaan
recommend_drama_count("My Mister")

"""### Perbandingan Kedua Pendekatan

Pendekatan TF-IDF cenderung lebih baik dalam menangkap nuansa semantik karena memperhitungkan kata-kata yang jarang muncul tapi memiliki makna kuat.

Pendekatan CountVectorizer memberi bobot yang lebih eksplisit terhadap semua kata, namun bisa bias terhadap kata-kata umum yang sering muncul di berbagai sinopsis.

Dengan membandingkan kedua pendekatan ini, kita dapat mengevaluasi mana yang memberikan hasil rekomendasi lebih relevan terhadap kebutuhan pengguna.
"""

def evaluate_precision_recall(title, top_n=5):
    idx = indices.get(title)
    input_genres = set(df_filtered.loc[idx, 'Genre'].split(", "))
    sim_scores = sorted(list(enumerate(cosine_sim[idx])), key=lambda x: x[1], reverse=True)[1:top_n+1]
    relevant = 0
    for i, _ in sim_scores:
        genres = set(df_filtered.iloc[i]['Genre'].split(", "))
        if input_genres & genres:
            relevant += 1
    precision = relevant / top_n
    recall = relevant / len(input_genres) if input_genres else 0
    f1 = 2 * (precision * recall) / (precision + recall + 1e-8)
    return f"Precision@{top_n}: {precision:.2f}, Recall@{top_n}: {recall:.2f}, F1-Score@{top_n}: {f1:.2f}"

evaluate_similarity("My Mister")
evaluate_precision_recall("My Mister")